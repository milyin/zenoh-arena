# zenoh-arena

The library zenoh-arena implements peer-to-peer network framework for simple game applications based on https://docs.rs/zenoh/latest/zenoh/ network library.

Each applicatioon instance have unique name. If other host with this name is found (with liveliness) application aborts. The name is autogenerated.

Each application can be either in `host` or `client` state. It can change state depending on conditions.
If not explicitly configured, application starts as client. It looks for existing hosts using https://docs.rs/zenoh/latest/zenoh/query/struct.Querier.html. If host answers positively, the client is accepted. The client should confirm the connection with second specific `get` to keyexpr of this host.
and connects to first found. If no hosts found, application becomes host. 

The host can be `empty` or not. The `empty` means that no clients are connected to the host.

The host can be `open` or `closed`. Open host accepts new clients, closed do not. The `open` host listens to clients requests using https://docs.rs/zenoh/latest/zenoh/query/struct.Queryable.html API. The host not accepting clients closes the queryable.

In some conditions host may close itself and switch to initial client host searching state. For example this may heppen:
- when game session ended
- when host is `empty` it may try to stop being a host to try to look for other hosts
- by explicit user request

Application can't be at the same moment in the host and client state. It should first close the host (stop accepting cliens) and only then start to search for other hosts.

The `host` declares the https://docs.rs/zenoh/latest/zenoh/liveliness/index.html token allowing the clients to know if host is disconnected.

If client sees that the host is disconnected, it swithches to initial host-searching mode and then becomes host if no other hosts found. Timeout for host searching is randomized.

There are the following API surfaces (`framework` is the zenoh-arena library)
- user interface <-> framework. User interface may be unaware if the framework is in host or client mode. The framework accepts data of type ACTION and gives data of type STATE. These types supports serialization (https://docs.rs/zenoh-ext/latest/zenoh_ext/) and either delivered to remote host or processed locally.

- framework <-> game engine. When framework is in host mode, it starts game engine instance. It forward ACTIONs to it and distributes STATEs to connected clients.

- framework <-> framework. This API is internal, it's how nodes connects to each other using zenoh network API.

# z_tetris application

This application demonstrates usage of zenoh-arena.
It uses https://github.com/milyin/gametetris-rs library as a game engine
It's a single terminal application. When runned it searches for other instances. If not found, it becomes host itself.
The host accepts only one client. When client is accepted, pair tetris game is started.
If game is lost in cliend mode, client is disconnected from host and goes to host-searching state. Host continues playing the same game, new clients connects to existing host state.
It host loses game, it closes host. The winner client tries to connect to other hosts or then start the host itself with it's current game state.